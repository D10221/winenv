#!/usr/bin/env bash
#
# Sets env vars and paths
# to help run an arbitrary command
# on steam wine/proton app prefixes
#

# meta
version=0.0.8
name=$(basename $0)
_dir="$(
    cd -- "$(dirname "$0")" >/dev/null 2>&1
    pwd -P
)"
_name="$_dir/$name"
url="https://github.com/D10221/$name"
fetch="https://raw.githubusercontent.com/D10221/$name/main/$name"
desc='Sets env vars and paths to help run an arbitrary command on steam wine/proton app prefixes'
#
function error {
    echo $1>&2
    exit $2
}
# usage
if [ -z "$1" ]; then
    echo "${name}: v${version} ${url}"
    echo
    echo "'$desc'"
    echo
    echo "Usage: "
    echo "\$ $name # with no arg, shows this"
    echo "\$ $name <APPID>' # show env for <APPID>"
    echo "\$ $name <APPID> <COMMAND>' # run <command> with <APPID>'s env"
    echo "\$ $name <install|uninstall|update>' # Not implemented"
    exit
fi
#
function make_config {
    mkdir -p "$(dirname $cfg_global)"
    echo "#!/usr/bin/env bash
# steam
STEAM_COMPAT_CLIENT_INSTALL_PATH=\$HOME/.local/share/Steam
# '$name'
${name^^}_CONFIG=\$HOME/.config/$name/.$name
" >"$cfg_global"
}
# config
cfg_global="$HOME/.config/$name/.$name" # "~/.config/winenv/.winenv"
cfg_cwd="$PWD/.$name"                    # "./.winenv"
if [ -f "$cfg_cwd" ]; then
    source "$cfg_cwd"
elif [ -f "$cfg_global" ]; then
    source "$cfg_global"
else
    make_config
    source "$cfg_global"
fi
# self update
function get_version {
    IFS='='
    read -ra values <<<"$1"
    echo "${values[1]}"
}
install_target="$HOME/.local/bin/$name"
case "${1}" in
install)
    # install into user/bin
    if [ -f $install_target ]; then
        echo "$name is already installed" >&2
        exit 1
    fi
    cp "$_name" $install_target
    exit
    ;;
uninstall)
    # remove from user system
    if [ ! -f $install_target ]; then
        echo "$name is not installed" >&2
        exit 1
    fi
    rm "$HOME/.local/bin/$name" -rf
    rm "${name^^}_CONFIG" -rf
    echo "get it from $url"
    exit
    ;;
update)
    # download new version
    tmp=$(mktemp)
    curl $fetch >$tmp
    new_version="$(get_version "$(grep "version=" $tmp)")"
    if [ -z "$new_version" ]; then
        echo "error: can't udpate, see file: '$tmp' version ($new_version) is not valid or not foud"
        exit 1
    elif [[ "$version" > "$new_version" ]]; then
        echo "error: can't udpate, see file: '$tmp' version ($new_version) is mayor than this version ($version)"
        exit 1
    elif [[ "$new_version" == "$version" ]]; then
        echo "error: can't udpate, see file: '$tmp' version ($new_version) equals this ($version)"        
        exit 1
    elif [[ "$new_version" > "$version" ]]; then
        bakd="$HOME/.local/share/$name"
        bak="$bakd/$name.$version.bak"
        mkdir -p "$bakd" && cp "$_name" "$bak" && cat "$tmp" >"$_name" && echo "Updated: see backup at $bak" && exit 0 || echo "error updating" && exit 1
    fi
    exit
    ;;
update-config)
    make_config
    cat "$cfg_global"
    echo "$cfg_global"
    exit
    ;;
esac
# All Installed apps manifests
libraryfolders=$STEAM_COMPAT_CLIENT_INSTALL_PATH/config/libraryfolders.vdf
#
function get_appmanifests
{
    read -d "\n" -ra _folders <<<"$(cat $libraryfolders | vdf2json|jq '.libraryfolders[].path? ' )"
for libraryfolder in "${_folders[@]}"; do
    libraryfolder=$(echo $libraryfolder|tr -d \") # remove quotes
    entries=$(ls $libraryfolder/steamapps/appmanifest_*.acf)  
    read -d " "  -ra _entries <<<$entries
    for appmanifest in "${_entries[@]}"; do
        manifest=$(cat $appmanifest | vdf2json | jq )
        args="--arg libraryfolder $libraryfolder --arg appmanifest $appmanifest"
        echo $manifest | jq $args '.AppState | {name,appid,installdir,libraryfolder:$libraryfolder, appmanifest:$appmanifest}'
    done    
done
}
#
appmanifest=$(get_appmanifests | jq -s)
#
function get_appmanifest_by_id 
{
    echo $appmanifest |jq --argjson id "$1" '.[]| select(.appid==$id)'
}
#
APPID=$1;shift
# if $APPID is not a number
re='^[0-9]+$'
if ! [[ $APPID =~ $re ]]; then
ID_SEARCH=$APPID && echo "'$APPID' is not a number, searching for appid.">&2  && APPID=$(echo $appmanifest | jq --arg N $APPID '.[]|select(.name|test($N;"i"))|.appid') \
&& [[ $APPID =~ $re ]] \
&& echo found APPID=$APPID >&2 \
|| error "Can't find app id for '$ID_SEARCH', search result '$APPID 'is not a number" 1
fi

# By ID
appmanifest_by_id=$(get_appmanifest_by_id $APPID)
APP_MANIFEST=$( echo $appmanifest_by_id |jq '.appmanifest' |tr -d \")
APP_DIR=$( echo $appmanifest_by_id |jq '.libraryfolder+"/steamapps/common/"+.installdir')

# STEAM_COMPAT_DATA_PATH
STEAM_COMPAT_DATA_PATH=$(echo $appmanifest_by_id| jq --arg id $APPID '.libraryfolder+"/steamapps/compatdata/"+$id'|tr -d \")
if [ ! -d "$STEAM_COMPAT_DATA_PATH" ]; then
    error "STEAM_COMPAT_DATA_PATH='$STEAM_COMPAT_DATA_PATH' is not a directory" 1
fi

#  wine prefix
WINEPREFIX="$STEAM_COMPAT_DATA_PATH/pfx"
if [ ! -d "$WINEPREFIX" ]; then
    error "WINEPREFIX=$WINEPREFIX is not a directory" 1    
fi

#  Compat tool Version
COMPAT_TOOL_VERSION=$(cat $STEAM_COMPAT_DATA_PATH/version)
if [ -z "$COMPAT_TOOL_VERSION" ]; then
    error "Can't find COMPAT_TOOL_VERSION for APPID=$APPID with STEAM_COMPAT_DATA_PATH=$STEAM_COMPAT_DATA_PATH" 1    
fi
# Compat tool path
COMPAT_TOOL_PATH="$STEAM_COMPAT_CLIENT_INSTALL_PATH/compatibilitytools.d/$COMPAT_TOOL_VERSION"
if [ ! -d "$COMPAT_TOOL_PATH" ]; then
    error "COMPAT_TOOL_PATH='$COMPAT_TOOL_PATH' is not a directory" 1
fi
# proton
PROTON="$COMPAT_TOOL_PATH/proton"
if [ ! -f "$PROTON" ]; then
    error "PROTON='$PROTON' is not a file" 1
fi
# wine
WINE=$COMPAT_TOOL_PATH/files/bin/wine # GE-Proton
if [ ! -f "$WINE" ]; then
    error "WINE='$WINE' is not a file" 1
fi
# exports
x="export APPID=$APPID &&"
x+="export APP_MANIFEST=$APP_MANIFEST &&"
x+="export APP_DIR="$APP_DIR" &&"
x+="export WINEPREFIX=$WINEPREFIX &&"
x+="export WINE=$WINE &&"
x+="export PROTON=$PROTON &&"
x+="export STEAM_COMPAT_DATA_PATH=$STEAM_COMPAT_DATA_PATH &&"
x+="export STEAM_COMPAT_CLIENT_INSTALL_PATH=$STEAM_COMPAT_CLIENT_INSTALL_PATH &&"
x+="export PATH=$COMPAT_TOOL_PATH:$COMPAT_TOOL_PATH/files/bin:$PATH"
# show env if no args left
if [ -z "$1" ]; then
    IFS='&&'
    read -ra a1 <<<$x
    for i in "${a1[@]}"; do
        if [ ! -z "$i" ]; then
            echo $i |tr -d 'export '
        fi
    done
    exit
fi
# run
cmd="$x && $1"
# echo cmd="$cmd"
bash -c "$cmd" 
