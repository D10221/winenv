#!/usr/bin/env bash
#
# Sets env vars and paths
# to help run an arbitrary command
# on steam wine/proton app prefixes
#

# this meta
SELF_VERSION=0.0.8
SELF_NAME=$(basename $0)
SELF_DIR="$(
    cd -- "$(dirname "$0")" >/dev/null 2>&1
    pwd -P
)"
SELF_PATH="$SELF_DIR/$SELF_NAME"
SELF_URL="https://github.com/D10221/$SELF_NAME"
SELF_SOURCE_URL="https://raw.githubusercontent.com/D10221/$SELF_NAME/main/$SELF_NAME"
SELF_DESC='Sets env vars and paths to help run an arbitrary command on steam wine/proton app prefixes'
SELF_INSTALL_TARGET="$HOME/.local/bin/$SELF_NAME"
# VARS
STEAM_COMPAT_CLIENT_INSTALL_PATH=${STEAM_COMPAT_CLIENT_INSTALL_PATH:-$HOME/.local/share/Steam}
#
# output $1 to stderr and exit if $2
#
function error {    
    # colors
    local RED='\033[0;31m'
    local YELLOW='\033[1;33m'
    local LIGHT_BLUE='\033[1;34m'
    local LIGHT_GREEN='\033[1;32m'
    local NOCOLOR='\033[0m' # No Color    
    local COLOR=$NOCOLOR
    pfx="$LIGHT_GREEN${SELF_NAME^}:"
    if [ ! -z "$2" ] ;then
        if [ $2 -gt 0 ];then 
            COLOR=$RED # if exit code > 0
            pfx+="${YELLOW}${FUNCNAME[0]}:${FUNCNAME[1]}: "
        else
            pfx+="${LIGHT_BLUE}${FUNCNAME[1]}: "
            COLOR=$YELLOW
        fi    
    else
        pfx+="${YELLOW}${FUNCNAME[1]}: "
        COLOR=$LIGHT_BLUE
    fi
    echo -e "$pfx${COLOR}$1${NOCOLOR}">&2
    if ! [ -z "$2" ] ; then    
     exit $2 # if exist code , exit
    fi
}
#
function get_appmanifests
{
    local libraryfolders=$STEAM_COMPAT_CLIENT_INSTALL_PATH/config/libraryfolders.vdf
    if ! [ -f "$libraryfolders" ];then
        error "libraryfolders=$libraryfolders is not a file" 1
    fi
    read -d "\n" -ra _folders <<<"$(cat $libraryfolders | vdf2json|jq '.libraryfolders[].path? ' )"
    for libraryfolder in "${_folders[@]}"; do
        libraryfolder=$(echo $libraryfolder|tr -d \") # remove quotes
        entries=$(ls $libraryfolder/steamapps/appmanifest_*.acf)
        read -d " "  -ra _entries <<<$entries
        for appmanifest in "${_entries[@]}"; do
            manifest=$(cat $appmanifest | vdf2json | jq )
            args="--arg libraryfolder $libraryfolder --arg appmanifest $appmanifest"
            echo $manifest | jq $args '.AppState | {name,appid,installdir,libraryfolder:$libraryfolder, appmanifest:$appmanifest}'
        done
    done
}
#
function get_app_id_by_name ()
{
    echo $1 | jq --arg N $2 '.[]|select(.name|test($N;"i"))|.appid'
}
function get_appmanifest_by_id
{
    echo $1 |jq --argjson id $2 '.[]| select(.appid==$id)'
}
#
# if $APPID is not a number, search app id by name
function maybe_app_id (){
    local APPID_REGEX='^[0-9]+$'
    local APPID=$1
    if ! [[ $APPID =~ $APPID_REGEX ]]; then
        ID_SEARCH=$APPID
        error "'$APPID' is not an ID searching for app id by name like '$APPID'"
        APPID=$(get_app_id_by_name "$appmanifest" "$ID_SEARCH")
        if ! [[ $APPID =~ $APPID_REGEX ]]; then
            error "Can't find app id for '$ID_SEARCH', search result '$APPID 'is not an app id." 1
        fi
    fi
    echo $APPID
}
#
function showenv ()
{
    IFS='&&'
    read -ra a1 <<<"$1"
    for i in "${a1[@]}"; do
        if [ ! -z "$i" ]; then
            echo ${i/export /''}
        fi
    done
}
#
# show info in json format for givev $1="app id or name" f
#
function show_info (){
    local appmanifest=$(get_appmanifests | jq -s)
    if [ -z "$1" ]; then
        echo $appmanifest
    else
        local APPID
        APPID=$(maybe_app_id $1) && echo $(get_appmanifest_by_id "$appmanifest" "$APPID")
    fi
}
#
function show_id ()
{
    if [ -z "$1" ];then 
         error "name required" 1
    fi
    local APPID=''tool
}
#
# arg: $1 = app name or id
#
function compatdata()
{
   local appmanifest=$(get_appmanifests | jq -s) # used by maybe_app_id   
   local APPID
   local STEAM_COMPAT_DATA_PATH
   local appmanifest_by_id
   APPID=$(maybe_app_id $1) \
   && appmanifest_by_id=$(get_appmanifest_by_id "$appmanifest" "$APPID") \
   && echo $(echo $appmanifest_by_id| jq --arg id $APPID '.libraryfolder+"/steamapps/compatdata/"+$id'|tr -d \")   
}
#
# Get compat tool version by id
# arg: $1 = app name or id
#
function compatToolVersion ()
{
    #  Compat tool Version
    local STEAM_COMPAT_DATA_PATH=$(compatdata $1)
    local COMPAT_TOOL_VERSION=$(cat $STEAM_COMPAT_DATA_PATH/version)
    [ -z "$COMPAT_TOOL_VERSION" ] &&
    error "Can't find COMPAT_TOOL_VERSION for APPID=$APPID with STEAM_COMPAT_DATA_PATH=$STEAM_COMPAT_DATA_PATH" 1 \
    || echo $COMPAT_TOOL_VERSION
    }
#
# find proton in $libraryfolder by COMPAT_TOOL_VERSION
#
function findProton ()
{
    local libraryfolder=$1
    while IFS= read -r line
    do
        if [ "Python script, ASCII text executable"  == "$(file -b "$line")" ]; then 
            v=$(grep -Po '^(\s+)?CURRENT_PREFIX_VERSION=\K\"(.*)\"' "$line" | tr -d \")
            if [ ! -z "$v" ] && [ "$v" == "$COMPAT_TOOL_VERSION" ]; then
                echo $line
            fi
        fi
    done <<<"$(find $libraryfolder/steamapps/common/* -type f -executable -name proton)"
}
#
# 
#
function listProtons (){
    read -d "\n" -ra libraryfolders<<<"$(getLibraryfolderPaths)"
    for libraryfolder in "${libraryfolders[@]}"; do
        find $libraryfolder/steamapps/common/* -type f -executable -name proton
    done
}
#
# arg: $1 = app name or id
# finding proton
#  if version in '/compatibilitytools.d'
#  or in same $libraryfolder
#  or in $STEAM_COMPAT_CLIENT_INSTALL_PATH/steamapps/common/Proton*?
#
function compatToolPath ()
{
    local COMPAT_TOOL_VERSION=$(compatToolVersion $1)
    # custom compat tool like GE-Proton
    local compatibilitytools="$STEAM_COMPAT_CLIENT_INSTALL_PATH/compatibilitytools.d"
    local COMPAT_TOOL_PATH="$compatibilitytools/$COMPAT_TOOL_VERSION" &&
    if [ ! -z "$COMPAT_TOOL_VERSION" ] &&  [ -d "$COMPAT_TOOL_PATH" ]; then
        echo $COMPAT_TOOL_PATH
        exit # done
    else
        error "version='$COMPAT_TOOL_VERSION' not in '$compatibilitytools'"
    fi
    local appmanifest=$(get_appmanifests | jq -s)   
    local APPID=$(maybe_app_id $1) 
    appmanifest_by_id=$(get_appmanifest_by_id "$appmanifest" "$APPID")
    # 
    local libraryfolder=$(echo $appmanifest_by_id| jq '.libraryfolder' | tr -d \")        
    protons=$(find $libraryfolder/steamapps/common/* -type f -executable -name proton)    
    proton=$(findProton $libraryfolder)
    if [ ! -z "$proton" ]; then
        echo $proton
        exit # done
    fi
    # search in STEAM_COMPAT_CLIENT_INSTALL_PATH (default location) ?
    libraryfolder=$STEAM_COMPAT_CLIENT_INSTALL_PATH
    proton=$(findProton $libraryfolder)
    if [ ! -z "$proton" ]; then
        echo $proton
        exit # done
    fi
    # Not found
    error "version='$COMPAT_TOOL_VERSION' not in '$libraryfolder/steamapps/common'"  1
}
#
function getLibraryfolderPaths ()
{
    local libraryfolders=$STEAM_COMPAT_CLIENT_INSTALL_PATH/config/libraryfolders.vdf
    read -d "\n" -ra _folders <<<"$(cat $libraryfolders | vdf2json|jq '.libraryfolders[].path? ' )"
    for libraryfolder in "${_folders[@]}"; do
        libraryfolder=$(echo $libraryfolder|tr -d \") # remove quotes
        echo $libraryfolder
    done
}
# 
# ex: 'appmanifest 244210 # prints path/to/appmanifest
# ex: 'appmanifest 244210 | xargs cat | vdf2json |jq' # print appmanifest in json format
#
function getAppmanifestPathByID ()
{
    APPID=$(maybe_app_id $1)    
    read -d "\n" -ra libraryfolders<<<"$(getLibraryfolderPaths)"
    for libraryfolder in "${libraryfolders[@]}"; do                
        entries=$(ls $libraryfolder/steamapps/appmanifest_*.acf)
        read -d " "  -ra _entries <<<$entries
        for appmanifest in "${_entries[@]}"; do
            #  manifest=$(cat $appmanifest | vdf2json | jq )
            #  args="--arg libraryfolder $libraryfolder --arg appmanifest $appmanifest"
            #  echo $manifest | jq $args '.AppState | {name,appid,installdir,libraryfolder:$libraryfolder, appmanifest:$appmanifest}'            
            if [ -z  "$APPID" ]; then
                echo $appmanifest 
            elif [ ! -z  "$APPID" ] && [ "$libraryfolder/steamapps/appmanifest_$APPID.acf" == "$appmanifest" ]; then
                echo $appmanifest
                exit
            fi
        done
    done
}
#
function config-info ()
{
   local appmanifest=$(get_appmanifests | jq -s) # used by maybe_app_id   
   local APPID
   local STEAM_COMPAT_DATA_PATH
   local appmanifest_by_id
   APPID=$(maybe_app_id $1) \
   && appmanifest_by_id=$(get_appmanifest_by_id "$appmanifest" "$APPID") \
   && STEAM_COMPAT_DATA_PATH=$(echo $appmanifest_by_id| jq --arg id $APPID '.libraryfolder+"/steamapps/compatdata/"+$id'|tr -d \") \
   && cat "$STEAM_COMPAT_DATA_PATH/config_info" \
   || error "No APPID" 1
}
#
function usage(){
    echo "$SELF_NAME: v$SELF_VERSION $SELF_URL"
    echo
    echo "'$SELF_DESC'"
    echo
    echo "Usage: "
    echo " $SELF_NAME # with no args, shows this"
    echo " $SELF_NAME [APPID|APP_NAME]' # show env for APPID or APP_NAME"
    echo " $SELF_NAME [APPID|APP_NAME] [COMMAND]' # run COMMAND with <APPID or APP_NAME>'s env"
    echo " $SELF_NAME [APPID|APP_NAME] [COMMAND]' # run COMMAND with <APPID or APP_NAME>'s env"
    echo " $SELF_NAME info ' # show info for all installed apps, returns json format"
    echo " $SELF_NAME info [APPID|APP_NAME]' # show info for [APPID|APP_NAME], returns json format"
    echo " $SELF_NAME id [APP_NAME]' # search for appid for given name match, returns json format"
    echo " $SELF_NAME install' # install '$SELF_NAME' script into ~/.local/bin"
    echo " $SELF_NAME uninstall' # remove '$SELF_NAME' script into ~/.local/bin"
    echo " $SELF_NAME update' # update '$SELF_NAME' script"
    echo "Config:"
    echo " \$STEAM_COMPAT_CLIENT_INSTALL_PATH # defaults to '~/.local/share/Steam'"
}
# this script version
function get_version {
    IFS='='
    read -ra values <<<"$1"
    echo "${values[1]}"
}
# install into user/bin
function self_install()
{
    [ -f $SELF_INSTALL_TARGET ] \
    && error "$SELF_NAME is already installed" 1 \
    || cp "$SELF_PATH" "$SELF_INSTALL_TARGET" \
    && echo "installed: '$SELF_INSTALL_TARGET'"
}
# remove from user system
function self_uninstall ()
{
    rm "$SELF_INSTALL_TARGET" \
    &&  echo "uninstalled: '$SELF_INSTALL_TARGET'" \
    || error "$SELF_NAME is not installed" 1
}
#
function self_update ()
{
    # download new version
    local tmp=$(mktemp)
    curl $fetch >$tmp
    local new_version="$(get_version "$(grep "version=" $tmp)")"
    if [ -z "$new_version" ]; then
        echo "error: can't udpate, see file: '$tmp' version ($new_version) is not valid or not foud"
        exit 1
    elif [[ "$SELF_VERSION" > "$new_version" ]]; then
        echo "error: can't udpate, see file: '$tmp' version ($new_version) is mayor than this version ($SELF_VERSION)"
        exit 1
    elif [[ "$new_version" == "$SELF_VERSION" ]]; then
        echo "error: can't udpate, see file: '$tmp' version ($new_version) equals this ($SELF_VERSION)"
        exit 1
    elif [[ "$new_version" > "$SELF_VERSION" ]]; then
        local bakd="$HOME/.local/share/$SELF_NAME"
        local bak="$bakd/$SELF_NAME.$SELF_VERSION.bak"
        mkdir -p "$bakd" && cp "$SELF_PATH" "$bak" && cat "$tmp" >"$SELF_PATH" && error "Updated: see backup at $bak" 0 || error "error updating" 1
    fi
}
#
function getLocalConfig (){
    USERID='*'
    echo $(ls $STEAM_COMPAT_CLIENT_INSTALL_PATH/userdata/$USERID/config/localconfig.vdf)
    # find $STEAM_COMPAT_CLIENT_INSTALL_PATH/userdata -name localconfig.vdf
}
#
function main ()
{
    # All Apps
    local appmanifest=$(get_appmanifests | jq -s)
    #
    local APPID
    APPID=$(maybe_app_id $1) || exit 1
    # App's manifest
    local appmanifest_by_id=$(get_appmanifest_by_id "$appmanifest" "$APPID")
    #
    local APP_MANIFEST=$( echo $appmanifest_by_id |jq '.appmanifest' |tr -d \")
    #
    local APP_DIR=$( echo $appmanifest_by_id |jq '.libraryfolder+"/steamapps/common/"+.installdir' | tr -d \")
    #
    local APP_NAME=$( echo $appmanifest_by_id |jq '.name')
    # STEAM_COMPAT_DATA_PATH
    local STEAM_COMPAT_DATA_PATH=$(echo $appmanifest_by_id| jq --arg id $APPID '.libraryfolder+"/steamapps/compatdata/"+$id'|tr -d \")
    if [ ! -d "$STEAM_COMPAT_DATA_PATH" ]; then
        error "STEAM_COMPAT_DATA_PATH='$STEAM_COMPAT_DATA_PATH' is not a directory" 1
    fi
    #  wine prefix
    local WINEPREFIX="$STEAM_COMPAT_DATA_PATH/pfx"
    if [ ! -d "$WINEPREFIX" ]; then
        error "WINEPREFIX=$WINEPREFIX is not a directory" 1
    fi
    #  Compat tool Version
    local COMPAT_TOOL_VERSION=$(cat $STEAM_COMPAT_DATA_PATH/version)
    if [ -z "$COMPAT_TOOL_VERSION" ]; then
        error "Can't find COMPAT_TOOL_VERSION for APPID=$APPID with STEAM_COMPAT_DATA_PATH=$STEAM_COMPAT_DATA_PATH" 1
    fi
    # Compat tool path
    local COMPAT_TOOL_PATH="$STEAM_COMPAT_CLIENT_INSTALL_PATH/compatibilitytools.d/$COMPAT_TOOL_VERSION"
    if [ ! -d "$COMPAT_TOOL_PATH" ]; then
        error "COMPAT_TOOL_PATH='$COMPAT_TOOL_PATH' is not a directory" 1
    fi
    # proton
    local PROTON="$COMPAT_TOOL_PATH/proton"
    if [ ! -f "$PROTON" ]; then
        error "PROTON='$PROTON' is not a file" 1
    fi
    # wine
    local WINE=$COMPAT_TOOL_PATH/files/bin/wine # GE-Proton
    if [ ! -f "$WINE" ]; then
        error "WINE='$WINE' is not a file" 1
    fi
    # exports
    WINENVx="export APPID=$APPID &&"
    WINENV+="export APP_DIR="$APP_DIR" &&"
    WINENV+="export APP_NAME="$APP_NAME" &&"
    WINENV+="export APP_MANIFEST=$APP_MANIFEST &&"
    WINENV+="export WINEPREFIX=$WINEPREFIX &&"
    WINENV+="export WINE=$WINE &&"
    WINENV+="export PROTON=$PROTON &&"
    WINENV+="export STEAM_COMPAT_DATA_PATH=$STEAM_COMPAT_DATA_PATH &&"
    WINENV+="export STEAM_COMPAT_CLIENT_INSTALL_PATH=$STEAM_COMPAT_CLIENT_INSTALL_PATH &&"
    WINENV+="export PATH=$COMPAT_TOOL_PATH:$COMPAT_TOOL_PATH/files/bin:$PATH"
    # show env if no args left
    if [ -z "$2" ]; then
        showenv "$WINENV" 
    else 
        # run
        cmd="$WINENV && $2"
        # echo cmd="$cmd"
        bash -c "$cmd"
    fi    
}
# Validate requirements
if ! [ -d "$STEAM_COMPAT_CLIENT_INSTALL_PATH" ]; then
    error "STEAM_COMPAT_CLIENT_INSTALL_PATH=$STEAM_COMPAT_CLIENT_INSTALL_PATH is not a directory" 1
fi
# process args
case "$1" in
    install)
        shift;
        (( $#  > 0 )) \
        && error "Too many args" 1 \
        || self_install \
        && exit
    ;;
    uninstall)
        shift;
        (( $#  > 0 )) \
        && error "Too many args" 1 \
        || self_uninstall
        exit
    ;;
    update)
        shift;
        (( $#  > 0 )) \
        && error "Too many args" 1 \
        || self_update
        exit
    ;;
    info)
        shift
        (( $#  > 1 )) \
        && error "Too many args" 1 \
        || show_info $1
        exit
    ;;
    id)
        shift
        (( $# > 1 )) \
        && error "Too many args" 1 \
        || show_id $1
        exit
    ;;
    config-info)
        shift
        (( $# < 1 )) \
        && error "expected name or id" 1 \
        || (( $# > 1 )) \
        && error "Too many args" 1 \
        || config-info $1
        exit
    ;;
    compatdata)
        shift
        (( $# < 1 )) \
        && error "expected name or id" 1 \
        || (( $# > 1 )) \
        && error "Too many args" 1 \
        || compatdata $1
        exit
    ;;
    compat-tool-version)
        shift
        (( $# < 1 )) \
        && error "expected name or id" 1 \
        || (( $# > 1 )) \
        && error "Too many args" 1 \
        || compatToolVersion $1
        exit
    ;;
    compat-tool-path)
        shift
        (( $# < 1 )) \
        && error "expected name or id" 1 \
        || (( $# > 1 )) \
        && error "Too many args" 1 \
        || compatToolPath $1
        exit
    ;;
    appmanifest)
        shift
        (( $# > 1 )) \
        && error "Too many args" 1 \
        || getAppmanifestPathByID $1
        exit
    ;;
    libraryfolders)
        shift
        (( $# > 0 )) \
        && error "Too many args" 1 \
        || getLibraryfolderPaths
        exit
    ;;
    proton-list)
        listProtons
        exit
    ;;
    localconfig)
        getLocalConfig $1
        exit
    ;;
    *)
        # usage when no args
        if (( $# == 0 )) ; then
            usage; exit
        fi        
        if (( $# > 2 )) ; then
            error "Too many args" 1
        fi
        main "$1" "$2"
        exit
        ;;
esac